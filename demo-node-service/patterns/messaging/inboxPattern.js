const EventEmitter = require('events');
const { v4: uuidv4 } = require('uuid');\n\nclass InboxPattern extends EventEmitter {\n    constructor() {\n        super();\n        this.processedMessages = new Set();\n        this.inboxEvents = new Map();\n    }\n    \n    async handleMessage(messageId, eventData) {\n        if (this.processedMessages.has(messageId)) {\n            this.emit('duplicateMessage', { messageId });\n            return true;\n        }\n        \n        const inboxEvent = {\n            messageId,\n            eventData,\n            receivedAt: Date.now(),\n            processed: false\n        };\n        \n        this.inboxEvents.set(messageId, inboxEvent);\n        \n        try {\n            await this.processEvent(eventData);\n            inboxEvent.processed = true;\n            this.processedMessages.add(messageId);\n            this.emit('messageProcessed', { messageId, eventData });\n            return true;\n        } catch (error) {\n            this.emit('messageProcessingFailed', { messageId, error: error.message });\n            return false;\n        }\n    }\n    \n    async processEvent(eventData) {\n        // Override in subclasses or provide custom processor\n        this.emit('eventProcessed', eventData);\n    }\n    \n    getProcessedCount() {\n        return this.processedMessages.size;\n    }\n    \n    getPendingCount() {\n        return Array.from(this.inboxEvents.values())\n            .filter(event => !event.processed).length;\n    }\n    \n    getStats() {\n        return {\n            processedCount: this.getProcessedCount(),\n            pendingCount: this.getPendingCount(),\n            totalReceived: this.inboxEvents.size\n        };\n    }\n}\n\nclass TwoPhaseCommit extends EventEmitter {\n    constructor() {\n        super();\n        this.participants = new Map();\n        this.transactions = new Map();\n    }\n    \n    addParticipant(name, participant) {\n        this.participants.set(name, participant);\n    }\n    \n    async executeTransaction(txId, operations) {\n        const transaction = {\n            id: txId,\n            status: 'PREPARING',\n            operations,\n            participants: Object.keys(operations),\n            createdAt: Date.now()\n        };\n        \n        this.transactions.set(txId, transaction);\n        this.emit('transactionStarted', { txId, operations });\n        \n        try {\n            // Phase 1: Prepare\n            for (const [name, operation] of Object.entries(operations)) {\n                const participant = this.participants.get(name);\n                if (!participant) {\n                    throw new Error(`Participant ${name} not found`);\n                }\n                \n                const prepared = await participant.prepare(txId, operation);\n                if (!prepared) {\n                    await this.abortTransaction(txId);\n                    throw new Error(`${name} failed to prepare`);\n                }\n            }\n            \n            transaction.status = 'COMMITTING';\n            \n            // Phase 2: Commit\n            for (const name of Object.keys(operations)) {\n                await this.participants.get(name).commit(txId);\n            }\n            \n            transaction.status = 'COMMITTED';\n            transaction.completedAt = Date.now();\n            \n            this.emit('transactionCommitted', { txId, transaction });\n            return transaction;\n            \n        } catch (error) {\n            await this.abortTransaction(txId);\n            this.emit('transactionFailed', { txId, error: error.message });\n            throw error;\n        }\n    }\n    \n    async abortTransaction(txId) {\n        const transaction = this.transactions.get(txId);\n        if (transaction) {\n            transaction.status = 'ABORTING';\n            \n            for (const participantName of transaction.participants) {\n                const participant = this.participants.get(participantName);\n                if (participant) {\n                    try {\n                        await participant.abort(txId);\n                    } catch (error) {\n                        this.emit('participantAbortFailed', { \n                            participant: participantName, \n                            txId, \n                            error: error.message \n                        });\n                    }\n                }\n            }\n            \n            transaction.status = 'ABORTED';\n            transaction.abortedAt = Date.now();\n            this.emit('transactionAborted', { txId });\n        }\n    }\n    \n    getTransactionStatus(txId) {\n        return this.transactions.get(txId);\n    }\n    \n    getStats() {\n        const transactions = Array.from(this.transactions.values());\n        return {\n            totalTransactions: transactions.length,\n            committed: transactions.filter(t => t.status === 'COMMITTED').length,\n            aborted: transactions.filter(t => t.status === 'ABORTED').length,\n            inProgress: transactions.filter(t => ['PREPARING', 'COMMITTING', 'ABORTING'].includes(t.status)).length,\n            participants: this.participants.size\n        };\n    }\n}\n\nclass TwoPhaseCommitParticipant extends EventEmitter {\n    constructor(name) {\n        super();\n        this.name = name;\n        this.preparedTransactions = new Set();\n    }\n    \n    async prepare(txId, operation) {\n        try {\n            await this.validateOperation(operation);\n            this.preparedTransactions.add(txId);\n            this.emit('prepared', { txId, participant: this.name });\n            return true;\n        } catch (error) {\n            this.emit('prepareFailed', { txId, participant: this.name, error: error.message });\n            return false;\n        }\n    }\n    \n    async commit(txId) {\n        if (!this.preparedTransactions.has(txId)) {\n            throw new Error(`Transaction ${txId} not prepared`);\n        }\n        \n        try {\n            await this.executeCommit(txId);\n            this.preparedTransactions.delete(txId);\n            this.emit('committed', { txId, participant: this.name });\n        } catch (error) {\n            this.emit('commitFailed', { txId, participant: this.name, error: error.message });\n            throw error;\n        }\n    }\n    \n    async abort(txId) {\n        if (this.preparedTransactions.has(txId)) {\n            this.preparedTransactions.delete(txId);\n        }\n        await this.executeAbort(txId);\n        this.emit('aborted', { txId, participant: this.name });\n    }\n    \n    async validateOperation(operation) {\n        // Override in subclasses\n        return true;\n    }\n    \n    async executeCommit(txId) {\n        // Override in subclasses\n    }\n    \n    async executeAbort(txId) {\n        // Override in subclasses\n    }\n    \n    getStats() {\n        return {\n            name: this.name,\n            preparedTransactions: this.preparedTransactions.size\n        };\n    }\n}\n\nmodule.exports = {\n    InboxPattern,\n    TwoPhaseCommit,\n    TwoPhaseCommitParticipant\n};